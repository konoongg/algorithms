# Shifr
Насмотревшись старого фильма "Хакеры", Маша решила придумать свой универсальный способ шифрования данных. Правда, пока эти данные могут состоять только из цифр, но Машу это заботит не сильно.

Пусть дана некоторая последовательность цифр A. i-ю цифру этой последовательности будем называть A[i]. Зашифрованная последовательность B при этом будет состоять из цифр B[i] = F(A[i], i), где F - некоторая функция, принимающая на вход цифру и ее позицию в последовательности.

Маша придумала вид функции F, но никак не может хорошо подобрать ее коэффициенты так, чтобы последовательность можно было и расшифровать (для этого нужно, чтобы каждой последовательности A соответствовала ровно одна последовательность B). Чтобы подбирать коэффициент было проще, Маша решила написать программу, которая для заданного коэффициента и заданной последовательности цифр B находит все соответствующие ей последовательности A. Помогите ей в этом.

Примечание

В качестве функции F Маша решила использовать функцию следующего вида:

int F(int value, int position, int seed) {
    int result = 0;
    for (size_t i = 1; i <= seed * seed; ++i) {
        result = (result + (i % 2 ? value + 1: position + 1) * i * seed) % 10;
    }
    return result;
}
В ней seed - это некоторый коэффициент, который Маша и пытается подобрать. Позиции нумеруются начиная с 0.

Формат ввода
В первой и единственной строке ввода через пробел задано три значения:

N: количество цифр в последовательности (1 < N < 200)
seed: коэффициент функции (1 < seed < 1000)
sequence: зашифрованная последовательность B
Формат вывода
Программа должна вывести как максимум 5 последовательностей A, соответствующих входной последовательности B. Среди всех возможных последовательностей программа должна в первую очередь выводить лексикографически самые большие из них в порядке убывания.

Если таких последовательностей A не существует, программа должны вывести No solutions.
